<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/x-icon" href="/assets/favicon.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=VT323&display=swap" rel="stylesheet">
    <link href="../posts.css" type="text/css" rel="stylesheet" />
    <link href="../../theme.css" type="text/css" rel="stylesheet" />
    <script defer src="../../index.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/base16/tomorrow-night.min.css" />
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <title>Diving into the React library</title>
  </head>
  <body>
      <!-- BLOG HEADER SECTION -->
    <header class="post-header-container">
      <h1 id="post-heading">Diving into the React library</h1>
        <p id="post-subheading">
          Getting familiar with one of the most popular JavaScript frameworks
        </p>
        <p id="post-date">Published May 24, 2022</p>
    </header>

    <!-- BLOG CONTENT SECTION -->
    <section class="blog-content-container">

      <article class="blog-post">
        <h3 class="content-subheading">Why use React?</h3>
        <p class="content-text">
          JavaScript is a powerful language that can be used both on the client-side and server-side (with Node.js); this makes it
          great for building anything from small projects to large-scale applications.  Whenever you're working with simple applications,
          plain JavaScript will usually suffice, but add more complexity to your application, and your codebase will quickly begin to
          get messy.  Luckily, frameworks fix this.
        </p>

        <p class="content-text">
          A framework is a collection of pre-written JavaScript code that you can use.  This, in turn, prevents you from
          trying to reinvent the wheel, and skyrockets productivity and efficiency.  There's several frameworks to choose
          from, but one of the most popular is React, which takes a "component-based" approach to JavaScript functions.
          Imagine the engineering behind a watch.  A watch is one working piece, but it's composed of hundreds of other
          smaller pieces, each with their own functionality.  React works similarly; anything in your application can be a component:
          buttons, forms, UIs, navigation menus, etc.  This, in essence, allows you to easily reuse components all
          across your application.
        </p>

        <br>
        <h3 class="content-subheading">Creating a React project</h3>
        <p class="content-text">
            Now that you have a basic understanding on how React works, it's time to create your very first React project.
            Keep in mind, React is a JavaScript library, which means that it builds off JavaScript.  In order to learn
            React, you must first have a strong proficiency with regular JavaScript and understand critical concepts like:
        </p>
        <ul class="content-list">
             <li class="content-list">Array manipulation using higher-order functions</li>
             <li class="content-list">Scoping and hoisting</li>
             <li class="content-list">Asynchronous code</li>
             <li class="content-list">Logical operators and type coercion</li>
             <li class="content-list">Making HTTP requests</li>
        </ul>
        <p class="content-text">
            ...knowing these fundamentals will make learning React feel like a breeze and simple be sugar on top of what
            you already know.
        </p>

         <p class="content-text">
            React applications can be set up from scratch, but this requires prior knowledge of other libraries like Babel and
            webpack.  The easiest way to create a React application is through Create React App, which automatically
            sets up a React environment by running one simple command.  To get started, open your terminal emulator and
            type this into the command line:
        </p>
        <pre><code class="language-shell">
$ npx create-react-app myfirstapplication
        </code></pre>
        <p class="content-text">
            ...this will create a new React project with the name of "myfirstapplication" inside your directory.  It'll take
            a few seconds for everything to install, but once it's done, your terminal emulator should look like this...
        </p>
        <img class="content-image" src="./images/new-react-project.png" alt="screenshot of terminal emulator message">
        <p class="content-text">
            ...open the project in VS Code and start your server by typing <code class="inline-code">npm start</code>.
            Your application should look like this...
        </p>
        <img class="content-image" src="./images/react-starter.png" alt="screenshot starter react application">
        <p class="content-text">
            ...awesome, your React environment is now running and ready for development!
        </p>

        <br>
        <h3 class="content-subheading">Building a component</h3>
        <p class="content-text">
            Now that your React environment is set up, you can start developing your application.  Because this article is
            a very surface-level introduction of React, I'll only be discussing components and props.  Other concepts like
            hooks and state management are beyond the scope of this beginner-friendly article.
        </p>

        <p class="content-text">
            Remember, components are simply reusable bits of code that serve the same purpose as JavaScript functions.
            In React, each component usually lives in it's own file.  The <code class="inline-code">App.js</code> file
            holds the <code class="inline-code">App</code> component.  By default, the <code class="inline-code">App</code>
            component comes with a few unnecessary lines of code.  Clean it up so it looks like this:
        </p>
        <pre><code class="language-javascript">
const App = () => {
  return (
    <div className="App">
    </div>
  );
}

export default App;
        </code></pre>
        <p class="content-text">
            ...React uses plenty of ES6 features, including arrow functions, which is why I transformed the
            <code class="inline-code">App</code> function.
        </p>







        <pre><code class="language-javascript">
console.log('a');
console.log('b');
console.log('c');

/*
a
b
c
*/
        </code></pre>
        <p class="content-text">
          ...in JavaScript, normal functions are synchronous.  <code class="inline-code">console.log()</code> is a function,
          that when invoked, prints out a message.  Here, you can see three letters printed out in the same order they were
          invoked, as expected.  Because JavaScript is synchronous, execution will always go something like this...
        </p>
        <ol class="content-list">
            <li class="content-list">JavaScript will reach the first function and invoke it, printing out <code class="inline-code">a</code>.</li>
            <li class="content-list">JavaScript will move to the second function and invoke it, printing out <code class="inline-code">b</code>.</li>
            <li class="content-list">JavaScript will move to the last function and invoke it, printing out <code class="inline-code">c</code>.</li>
        </ol>
        <p class="content-text">
          ...no matter how many times this code snippet is executed, it'll always run in the same order, from top-to-bottom.
          This, in essence, is the nature of synchronous code.
        </p>

        <br>
        <h3 class="content-subheading">Event queue and event loop</h3>
        <p class="content-text">
            Since JavaScript is single-threaded, it can only execute one thing at a time.  If you click a button on a website that does
            something, the thread will handle that task; if, after clicking that button, you immediately click another button,
            JavaScript will make a "mental note" to execute that task next.  This process is referred to as the <i>event queue</i>.  If there's
            tasks in the event queue, JavaScript will execute each one individually in corresponding order until the event queue is empty.
            Think of the event queue as a "to-do" list for the thread.
        </p>

        <p class="content-text">
            The process of continuously checking this "to-do" list is called the <i>event loop</i>.  If the event queue is empty,
            the thread "goes to sleep", but once an event is fired, the thread starts working again.  This synchronous behavior comes with
            a few problems.  What if you wanna' fetch data from an API?  An action like this might take a while; with synchronous code,
            everything after that request will have to wait until the data is received before it can continue executing the rest of the code.
            As you might imagine, this can drastically slow down performance.  Luckily, this is where asynchronous JavaScript shines.
        </p>

        <br>
        <h3 class="content-subheading">Asynchronous JavaScript</h3>
        <p class="content-text">
            Asynchronous code is code that can start something now and finish it later; it governs how you perform tasks that take a
            while to do, such as fetching data from an API.  In a nutshell, asynchronous code allows the program to be executed immediately,
            whereas synchronous code will block further execution of the remaining code until it finishes the current task.  One example of
            asynchronous code in action is the <code class="inline-code">setTimeout()</code> function:
        </p>
        <pre><code class="language-javascript">
setTimeout(() => {
  console.log('a')
}, 2000);

console.log('b');
console.log('c');
        </code></pre>
        <p class="content-text">
            ...the <code class="inline-code">setTimeout()</code> function takes a function that'll execute after a specified amount of time.  In this
            example, <code class="inline-code">a</code> will be printed out after 2 seconds.  Someone with no understanding of asynchronous code
            might assume the execution will look like this...
        </p>
        <ol class="content-list">
             <li class="content-list">JavaScript will wait 2 seconds, then print <code class="inline-code">a</code>.</li>
             <li class="content-list"><code class="inline-code">b</code> gets printed.</li>
             <li class="content-list"><code class="inline-code">c</code> gets printed.</li>
        </ol>
        <p class="content-text">
            ...but this assumption is incorrect.  Since <code class="inline-code">setTimeout()</code> is an asynchronous function, JavaScript
            will queue the inner function and move on to execute the rest of the code; once 2 seconds have passed, JavaScript will return to that
            function and execute it, so in actuality, the execution ends up looking more like this...
        </p>
        <ol class="content-list">
             <li class="content-list">JavaScript sees that <code class="inline-code">a</code> should be executed after 2 seconds.</li>
             <li class="content-list">JavaScript adds that task to the queue and moves on to execute the rest of the code.</li>
             <li class="content-list"><code class="inline-code">b</code> gets printed.</li>
             <li class="content-list"><code class="inline-code">c</code> gets printed.</li>
             <li class="content-list">2 seconds have passed.  Time to go back and execute that queued task now.</li>
             <li class="content-list"><code class="inline-code">a</code> gets printed.</li>
        </ol>
        <p class="content-text">
            ...with asynchronous code, the thread pretty much says "I'm not gonna' sit here and wait for this —  I got other things to do!  I'll
            come back to this when it's ready."  This ability to navigate the code freely is part of what makes asynchronous JavaScript so powerful.
        </p>

        <p class="content-text">
            That's the difference between synchronous and asynchronous code.  Synchronous code is executed line-by-line, top-to-bottom, whereas
            asynchronous code can freely move to the next line of code before the previous one has executed.  Asynchronous code is always "shoved aside" so synchronous
            code can run first.
        </p>

        <p class="content-text">
            For a more in-depth and visual explanation on the event loop, I highly recommend this amazing presentation by Philip Roberts:
        </p>
        <ul class="content-list">
            <li><a class="content-link" href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">What the heck is the event loop anyway? | Philip Roberts | JSConf EU</a></li>
        </ul>
      </article>
      
      <nav class="navigation-container">
        <p class="homepage-button">
          <a class="homepage-link" href="../../index.html">go back to homepage</a>
        </p>
      </nav>

    </section>

    <!-- FOOTER SECTION -->
    <footer class="footer-container">
      <p id="copyright">© Ismael Huerta | 2022</p>
    </footer>
  </body>
</html>